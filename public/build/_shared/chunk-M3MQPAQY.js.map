{
  "version": 3,
  "sources": ["../../../node_modules/accept-language-parser/index.js", "../../../app/helpers/i18n.ts"],
  "sourcesContent": ["var regex = /((([a-zA-Z]+(-[a-zA-Z0-9]+){0,2})|\\*)(;q=[0-1](\\.[0-9]+)?)?)*/g;\n\nvar isString = function(s){\n    return typeof(s) === 'string';\n};\n\nfunction parse(al){\n    var strings = (al || \"\").match(regex);\n    return strings.map(function(m){\n        if(!m){\n            return;\n        }\n\n        var bits = m.split(';');\n        var ietf = bits[0].split('-');\n        var hasScript = ietf.length === 3;\n\n        return {\n            code: ietf[0],\n            script: hasScript ? ietf[1] : null,\n            region: hasScript ? ietf[2] : ietf[1],\n            quality: bits[1] ? parseFloat(bits[1].split('=')[1]) : 1.0\n        };\n    }).filter(function(r){\n            return r;\n        }).sort(function(a, b){\n            return b.quality - a.quality;\n        });\n}\n\nfunction pick(supportedLanguages, acceptLanguage, options){\n    options = options || {};\n\n    if (!supportedLanguages || !supportedLanguages.length || !acceptLanguage) {\n        return null;\n    }\n\n    if(isString(acceptLanguage)){\n        acceptLanguage = parse(acceptLanguage);\n    }\n\n    var supported = supportedLanguages.map(function(support){\n        var bits = support.split('-');\n        var hasScript = bits.length === 3;\n\n        return {\n            code: bits[0],\n            script: hasScript ? bits[1] : null,\n            region: hasScript ? bits[2] : bits[1]\n        };\n    });\n\n    for (var i = 0; i < acceptLanguage.length; i++) {\n        var lang = acceptLanguage[i];\n        var langCode = lang.code.toLowerCase();\n        var langRegion = lang.region ? lang.region.toLowerCase() : lang.region;\n        var langScript = lang.script ? lang.script.toLowerCase() : lang.script;\n        for (var j = 0; j < supported.length; j++) {\n            var supportedCode = supported[j].code.toLowerCase();\n            var supportedScript = supported[j].script ? supported[j].script.toLowerCase() : supported[j].script;\n            var supportedRegion = supported[j].region ? supported[j].region.toLowerCase() : supported[j].region;\n            if (langCode === supportedCode &&\n              (options.loose || !langScript || langScript === supportedScript) &&\n              (options.loose  || !langRegion || langRegion === supportedRegion)) {\n                return supportedLanguages[j];\n            }\n        }\n    }\n\n    return null;\n}\n\nmodule.exports.parse = parse;\nmodule.exports.pick = pick;\n", "import { pick } from \"accept-language-parser\";\nimport i18nData from \"~/data/i18n.json\";\n\nconst FALLBACK_LANGUAGE = \"en\";\nconst FALLBACK_COUNTRY = \"ch\";\n\n/**\n * All available locales per country in the following format:\n * { [country code]: { [language code]: name } }\n */\nexport const locales: Record<string, Record<string, string>> = {\n  de: { en: \"English (Germany)\", de: \"Deutsche (Deutschland)\" },\n  ch: {\n    en: \"English (Switzerland)\",\n    fr: \"Fran\u00E7ais (Suisse)\",\n    de: \"Deutsche (Schweiz)\",\n  },\n};\n\nconst _i18n: Record<string, Record<string, string>> = i18nData;\nconst _computedLanguageCodes = Array.from(\n  new Set<string>(\n    Object.values(locales)\n      .map((languages) => Object.keys(languages))\n      .flat()\n  )\n);\n\n/**\n * Get localized keys for a given locale\n * @param locale - Locale code, e.g., \"en-ch\"\n * @param keys - Keys required\n * @returns Object containing localized terms\n */\nexport const loadTranslations = <T extends string>(\n  locale: string | undefined,\n  keys: readonly string[]\n): Record<T, string> => {\n  const languageCode = locale?.split(\"-\")[0] ?? FALLBACK_LANGUAGE;\n  const result: Record<string, string> = {};\n  keys.forEach(\n    (key) =>\n      (result[key] =\n        _i18n[languageCode][key] ?? _i18n[FALLBACK_LANGUAGE][key] ?? key)\n  );\n  return result;\n};\n\n/**\n * Get the IP address from an incoming Request, based\n * on https://github.com/pbojinov/request-ip\n * @param headers - Request headers\n * @returns IP address with a fallback value\n */\nconst getIpAddressFromRequest = (headers: Headers): string => {\n  for (const header in [\n    \"x-client-ip\",\n    \"x-forwarded-for\",\n    \"cf-connecting-ip\",\n    \"fastly-client-ip\",\n    \"true-client-ip\",\n    \"x-real-ip\",\n    \"x-cluster-client-ip\",\n    \"x-forwarded\",\n    \"forwarded-for\",\n    \"forwarded\",\n  ]) {\n    const value = headers\n      .get(header)\n      ?.split(\",\")\n      .map((value) => {\n        value = value.trim();\n        if (value.includes(\":\")) {\n          const splitted = value.split(\":\");\n          if (splitted.length === 2) return splitted[0];\n        }\n        return value;\n      })[0];\n    if (value) return value;\n  }\n  return \"1.1.1.1\";\n};\n\n/**\n * Get the recommended locale for a request using its `Accept-Language` header and IP address\n * @param headers - Request headers\n * @param currentLocale - Currently active locale\n * @returns Locale, e.g., \"en-ch\"\n */\nexport const getRecommendedLocale = async (\n  request: Request,\n  currentLocale?: string\n): Promise<string> => {\n  const { headers } = request;\n  const locale = pick(\n    _computedLanguageCodes,\n    headers.get(\"accept-language\") ?? \"\"\n  );\n  let recommendedCountryCode =\n    currentLocale?.split?.(\"-\")?.[1] ?? FALLBACK_COUNTRY;\n  if (!currentLocale)\n    try {\n      const ipAddress = getIpAddressFromRequest(headers);\n      const response = await fetch(`https://api.country.is/${ipAddress}`);\n      const data = await response.json();\n      const { country } = data as { country: string; ip: string };\n      const lowercased = country.toLowerCase();\n      if (Object.keys(locales).includes(lowercased))\n        recommendedCountryCode = lowercased;\n    } catch (error) {\n      console.error(error);\n    }\n  return `${locale ?? FALLBACK_LANGUAGE}-${recommendedCountryCode}`;\n};\n"],
  "mappings": ";;;;;;;AAAA;AAAA;AAAA;AAAA,QAAI,QAAQ;AAEZ,QAAI,WAAW,SAAS,GAAE;AACtB,aAAO,OAAO,MAAO;AAAA;AAGzB,mBAAe,IAAG;AACd,UAAI,UAAW,OAAM,IAAI,MAAM;AAC/B,aAAO,QAAQ,IAAI,SAAS,GAAE;AAC1B,YAAG,CAAC,GAAE;AACF;AAAA;AAGJ,YAAI,OAAO,EAAE,MAAM;AACnB,YAAI,OAAO,KAAK,GAAG,MAAM;AACzB,YAAI,YAAY,KAAK,WAAW;AAEhC,eAAO;AAAA,UACH,MAAM,KAAK;AAAA,UACX,QAAQ,YAAY,KAAK,KAAK;AAAA,UAC9B,QAAQ,YAAY,KAAK,KAAK,KAAK;AAAA,UACnC,SAAS,KAAK,KAAK,WAAW,KAAK,GAAG,MAAM,KAAK,MAAM;AAAA;AAAA,SAE5D,OAAO,SAAS,GAAE;AACb,eAAO;AAAA,SACR,KAAK,SAAS,GAAG,GAAE;AAClB,eAAO,EAAE,UAAU,EAAE;AAAA;AAAA;AAIjC,mBAAc,oBAAoB,gBAAgB,SAAQ;AACtD,gBAAU,WAAW;AAErB,UAAI,CAAC,sBAAsB,CAAC,mBAAmB,UAAU,CAAC,gBAAgB;AACtE,eAAO;AAAA;AAGX,UAAG,SAAS,iBAAgB;AACxB,yBAAiB,MAAM;AAAA;AAG3B,UAAI,YAAY,mBAAmB,IAAI,SAAS,SAAQ;AACpD,YAAI,OAAO,QAAQ,MAAM;AACzB,YAAI,YAAY,KAAK,WAAW;AAEhC,eAAO;AAAA,UACH,MAAM,KAAK;AAAA,UACX,QAAQ,YAAY,KAAK,KAAK;AAAA,UAC9B,QAAQ,YAAY,KAAK,KAAK,KAAK;AAAA;AAAA;AAI3C,eAAS,IAAI,GAAG,IAAI,eAAe,QAAQ,KAAK;AAC5C,YAAI,OAAO,eAAe;AAC1B,YAAI,WAAW,KAAK,KAAK;AACzB,YAAI,aAAa,KAAK,SAAS,KAAK,OAAO,gBAAgB,KAAK;AAChE,YAAI,aAAa,KAAK,SAAS,KAAK,OAAO,gBAAgB,KAAK;AAChE,iBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,cAAI,gBAAgB,UAAU,GAAG,KAAK;AACtC,cAAI,kBAAkB,UAAU,GAAG,SAAS,UAAU,GAAG,OAAO,gBAAgB,UAAU,GAAG;AAC7F,cAAI,kBAAkB,UAAU,GAAG,SAAS,UAAU,GAAG,OAAO,gBAAgB,UAAU,GAAG;AAC7F,cAAI,aAAa,iBACd,SAAQ,SAAS,CAAC,cAAc,eAAe,oBAC/C,SAAQ,SAAU,CAAC,cAAc,eAAe,kBAAkB;AACjE,mBAAO,mBAAmB;AAAA;AAAA;AAAA;AAKtC,aAAO;AAAA;AAGX,WAAO,QAAQ,QAAQ;AACvB,WAAO,QAAQ,OAAO;AAAA;AAAA;;;ACzEtB;AAAA,oCAAqB;AAUd,IAAM,UAAkD;AAAA,EAC7D,IAAI,EAAE,IAAI,qBAAqB,IAAI;AAAA,EACnC,IAAI;AAAA,IACF,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ,IAAI;AAAA;AAAA;AAKR,IAAM,yBAAyB,MAAM,KACnC,IAAI,IACF,OAAO,OAAO,SACX,IAAI,CAAC,cAAc,OAAO,KAAK,YAC/B;",
  "names": []
}
